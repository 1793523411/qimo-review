## 斐波那契数列 -- 动态规划

```cpp
int count = 1; //累计调用的步骤
int Fib(int n) //算法
{
	if (n == 1 || n == 2)
	{
		return 1;
	}
	else
	{
		int x = Fib(n - 1);
		int y = Fib(n - 2);
		return x + y;
	}
}
```

**使用动态规划**

为此避免重复设计，设计一个dp数组，dp[i]存放Fib(i)的值，首先设置dp[1]和dp[2]均为1，再让i从3到n循环以计算dp[3]到dp[n]的值，最后返回dp[n]即Fib1(n)

```cpp
int dp[MAX];	//所有元素初始化为0
int count = 1;	//累计调用的步骤
int Fib1(int n) //算法1
{
	dp[1] = dp[2] = 1;

	for (int i = 3; i <= n; i++)
	{
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	return dp[n];
}
```

## 求解最大连续子序列和问题

