## 填空题

- 面向对象的 7 条基本原则包括：**开闭原则、里氏替换原则、合成复用原则以及依赖倒转原则、单一原则、迪米特原则、接口隔离原则**。
- 在存在继承关系的情况下，方向像**超类**方向集中，而数据向**子类**方向集中。
- 设计模式的思想根源是**开闭**基本原则的宏观运用，本质上是没有任何模式的，发现模式的人永远是大师，而死守模式的人，最多只能是一个工匠。
- “要依赖于抽象，不要依赖于具体，即针对接口编程，不要针对实现编程”是**依赖倒转**原则的表述。
- 在找出了类的继承关系后，通常可以用**接口**来表示最上层的基类
- 设计模式的基本要素有**名称、目的、解决方案,实施后达到的效果**。
- 创建型模式的根本意图是要把**对象的创**建和**使用分离**的责任进行分离，从而降低系统的耦合度。
- 当需要在项目中定制自己的元素时，可以使用**创建型**模式来定制。
- 当创建一个具体的对象而又不希望指定具体的类时，可以使用**创建型**模式。
- 单例模式分为**懒汉式模式**和**饿汉式模式**两种。
- 原型模式包含：**抽象原型类**、**具体原型类**和**访问者类**等 3 个部分。
- 工厂模式分为**简单工厂**、**工厂方法**、**抽象工厂**3 种类型。
- 工厂方法模式的主要角色有：**抽象工厂**、**具体工厂**、**抽象产品**和**具体产品**。
- 抽象工厂模式是**工厂方法**模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产**多个等级**的产品。
- 建造者模式包括：**产品角色、抽象建造者、具体建造者、指挥者**等主要角色。
- 结构型模式分为：**装饰器模式，适配器模式，桥接模式，组合模式，享元模式，外观模式，代理模式**
- 代理模式的主要角色有：**抽象主题类，真是主题类，代理类**
- 适配器模式分为类适配器和对象适配器两种实现。其中，类适配器采用的是**继承**关系，对象适配器模式采用的是**组合/聚合**模式
- 适配器模式的主要角色有：**目标接口，适配者接口，适配器类**
- 当我们想将抽象部分和实现部分分离时，使他们可以独立变化，可以使用**桥接**模式
- 当桥接模式的实现化角色的接口与现有类的接口不一致时，可以再两者中间定义一个**适配器**将两者连接起来
- 装饰器模式主要包含以下角色：**抽象构件角色，具体构件角色，抽象装饰角色和具体装饰器**
- 外观模式是**迪米特**法则的典型运用
- 组合模式分为：**透明式**的组合模式和**非透明式**的组合模式
- 主要用于描述对类和对象怎样交互和怎样分配职责的模式是**行为型模式**
- 模板方法模式的基本方法是整个算法中的一个步骤，他包括**抽象方法，具体方法和钩子方法**
- 当封装不同算法并使用他们可以相互替换时，可以使用**策略**模式
- 当不同的请求对客户端进行参数化时，可以使用**命令**模式
- 职责链模式是一种**对象行为**模式，他将所有请求的处理者连成一条链
- 职责链模式存在在**纯的职责链模式**和**不纯的职责链模式**两种情况‘
- 状态模式包含**环境**角色，**抽象状态**角色和**具体状态**角色等主要角色
- MVC 模型的基本工作原理是基于**观察者**模式，实现是属于**命令**模式

## 简答题

### 设计模式按类型分为哪三类？简述各类型的含义

答：设计模式按类型分为以下三类：

1）创建型设计模式：以灵活的方式创建对象集合，用于管理对象的创建。

2）结构型设计模式：将己有的代码集成到新的面向对象设计中，用于处理类或对象的组合。

3）行为型设计模式：用于描述对类或对象怎样交互和怎样分配职责。

### 学习设计模式有什么意义？

答：正确使用设计模式具有以下优点：

⑴ 可以提高程序员的思维能力、编程能力和设计能力。

⑵ 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩 短软件的开发周期。

⑶ 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

### UML 类图中类之间存在哪几种关系？请根据类与类之间的耦合度从弱到强排列。

答：根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖 关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合 度相等，它们是最强的。

### 面向对象程序设计有哪几种设计原则？各有什么特点？

答：

1）开闭原则（OCP）：它要求软件实体应当对扩展开放，对修改关闭；

2）里氏替换原则（LSP）：它要求继承必须确保超类所拥有的性质在子类中仍然成立；

3）依赖倒置原则（DIP）：它要求软件设计要面向接口编程，不要面向实现编程；

4）单一职责原则（SRP）：它要求对象不应该承担太多职责，一个类应该有且仅有一个 引起它变化的原因；

5）接口隔离原则（ISP）：它要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体 的接口，让接口中只包含客户感兴趣的方法；

6）迪米特法则（LoD）：它要求如果两个软件实体无须直接通信，就不应当直接相互调 用，而通过第三方转发该调用；

7）合成复用原则（CRP）：它要求在软件复用时，要尽量先使用组合或者聚合等关联关 系来实现，其次才考虑使用继承关系来实现。

### 创建型模式分哪几种？简述每种创建型模式的定义。

创建型模式分为以下几种：

⑴ 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供 外部获取该实例，其拓展是有限多例模式。

⑵ 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和 原型类似的新实例。

⑶ 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生 产什么产品。

⑷ 抽象工厂（Abstract Factory）模式：提供一个创建产品族的接口，其每个子类可 以生产一系列相关的产品。

⑸ 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

### 使用工厂方法最主要的好处是什么？在哪里使用？

答：工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建 对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调 用层做任何修改。应用场合是常常有新的对象类型要被添加进来，但你所关心的仅仅是方法 的接口,不关心其实现细节，本书中已经详细地介绍了其好处和应用环境。

### 什么是代理模式？什么时候使用代理模式？

答： 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户
端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

代理模式有以下的应用场景：

1）为了隐藏目标对象存在于不同地址空间的事实，方便 客户端访问时；

2）要创建的目标对象开销很大时；

3）控制不同种类客户对真实对象的访问 权限时；

4）当调用目标对象需要附加一些额外的处理功能时；5）为了提高系统的性能，需 延迟对目标的加载时。

### 什么是适配器模式？举例说明 Java 实现适配器模式

答：适配器模式（Adapter）的定义如下: 将一个类的接口转换成客户希望的另外一 个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类 结构型模式和对象结构型模式 2 种，前者类之间的耦合度比后者高，且要求程序员了解现有 组件库中的相关组件的内部结构，所以应用相对较少些。 Java 例子可参考本章节相关实例设计。

### 简述行为型模型，并介绍一下 11 种行为型模式的定义。

答：行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间 怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及到算法与对象间职责的分配。 共有 11 种行为型模式，它们的定义如下：

⑴ 模板方法（Template Method）模式：定义一个操作中的算法骨架，而将算法的一些 步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

⑵ 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使他们可以 相互替换，且算法的改变不会影响到使用算法的客户。

⑶ 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求 的责任分割开。

⑷ 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对 象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

⑸ 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。

⑹ 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时， 把这种改变通知给其它多个对象，从而影响其它对象的行为。

⑺ 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降 低系统中对象间的耦合度，使原有对象之间不必相互了解。

⑻ 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而 不暴露聚合对象的内部表示。

⑼ 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提 供多种访问方式，即每个元素有多个访问者对象访问。

⑽ 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状 态，以便以后恢复它。

⑾ 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方 法，即解释器。

### 画出策略模式的结构图，并说明其应用场景

![](/14.png)

其应用场景有：

1）一个系统需要动态地在几种算法中选择一种时，可将每个算法封装 到策略类中；

2）一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句 的形式出现，可将每个条件分支移入到它们各自的策略类中以代替这些条件语句；

3）系统 中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时；

4）系统要求使用算法 的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构；

5）多 个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

### 命令模式的应用环境是什么？请举出若干应用实例。

答：命令模式通常适用以下场景：

1）当系统需要将请求调用者与请求接收者解耦时， 命令模式使得调用者和接收者不直接交互；

2）当系统需要随机请求命令或经常增加或删除 命令时，命令模式比较方便实现这些功能；

3）当系统需要执行一组操作时，命令模式可以 定义宏命令来实现该功能；

4）当系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作时,可以将命令对象存储起来，采用备忘录模式来实现。

## 大题

### 第一题

**1.WindowsMedia Player 和 RealPlayer 是两种常用的媒体播放器，它们的 API 结构和调用方法存在区别。现在应用程序需要支持这两种播放器 API，而且在将来可能还需要支持新的媒体播放器，请问：**

（1）使用什么模式设计该应用程序？

（2）如何画出其类图？

（3）如何正确解释该类图中的成员？

1．解：本题可使用适配器模式和抽象工厂模式，参考类图如下所示：

![](/d-1.png)

其中：

1）PlayerFactory 为抽象工厂，MediaPlayerFactory 和 RealPlayerFactory 是 具体工厂；

2）MainWindow（主窗口）和 PlayerList（播放列表）是两个抽象产品；

3）MediaPlayerWindow 和 RealPlayerWindow 是两个具体产品，是对 MainWindow 的实 现；

4）MediaPlayerList 和 RealPlayerList 是两个具体产品，是对 PlayerList 的实现；

5）MediaPlayerWindow 和 MediaPlayerList 由 MediaPlayerFactory 生产；

6）RealPlayerWindow 和 RealPlayerList 由 RealPlayerFactory 生产；

7）MediaPlayerAPI 是已有的 API，充当适配者，供 MediaPlayerWindow（适配器）和 MediaPlayerList（适配器）调用。

8）RealPlayerAPI 也是已有的 API，充当适配者，供 RealPlayerWindow（适配器）和 RealPlayerList（适配器）调用。

### 第二题

**2 ![](/d-2.jpg)**

1）本题使用了策略模式

2）其参考程序代码如下所示：

```java
interface TravelStrategy
{
    public void travel();
}
class AirplaneStrategy implements TravelStrategy
{
    public void travel()
    {
        System.out.println("飞机游！");
    }
}
class TrainStrategy implements TravelStrategy
{
    public void travel()
    {
        System.out.println("火车游！");
    }
}
class BicycleStrategy implements TravelStrategy
{
    public void travel()
    {
        System.out.println("自行车游！");
    }
}
class Person
{
    private TravelStrategy ts;
    public setStrategy(TravelStrategy ts)
    {
        this.ts=ts;
    }
    public void travelMethod()
    {
        ts.travelMethod();
    }
}
class Client
{
    public static void main(String args[])
    {
        TravelStrategy ts = new BicycleStrategy（）；
        Person p1 = new Person();
        p1.setStrategy(ts);
        P1.travelMethod();
    }
}
```

### 第三题

**4.正确选择所学的设计模式完成以下实例的设计：猫大叫一声，所有的老鼠都开始逃跑，主人被惊醒。即老鼠和主人的行为是被动的，猫是主动的。**

要求:
（1）正确设计模式

（2）画出其类图

解：本题可使用观察者模式，参考类图如下所示：

![](/d-3.png)

### 第四题

**5.基房地产公司欲开发-套房产信息管理系统， 根据如下描述选择合适的设计模式进行设计。**

**1.该公司有多种房型，如公寓、别墅等，在将来可能会增加新的房型。**

**2.销售人员每售出一套房子，主管将收到相应的销售消息。**

要求: 

(1)正确选择设计模式。

(2)画出其类图。

(3)正确解释该类图中的成员。

解：对于描述 1)可以选择使用工厂方法模式，对于描述 2)可以选择使用观察者模式， 
参考类图如下所示： 

![](/d-4.png)

在类图中，HouseCreator 是抽象房屋工厂类，其子类 VilladomCreator 用于创建别墅 Villadom，子类 ApartmentCreator 用于创建公寓 Apartment，Villadom 和 Apartment 都是抽象房屋类 House 的子类，此时应用了工厂方法模式，如果增加新类型的房屋，只需对应增 加新的房屋工厂类即可，原有代码无须做任何修改；House 类同时作为抽象观察目标，子类 Villadom 和 Apartment 作为具体观察目标，相关人员类 Stakeholder 作为抽象观察者，其 子类 Manager（主管）作为具体观察者，实现了在 Stakeholder 中声明的 response()方法， 当房屋售出时，房屋的状态 status 将发生变化，在 setStatus()方法中调用观察者的 response()方法，即主管将收到相应消息，此时应用了观察者模式。

### 第六题

**6.某旅游公司(如广之旅)欲利用假期为韶关学院学生开展夏令营活动，帮助大学生同国外大学生交流，根据如下描述选择合适的设计模式进行设计。**

**①该公司能帮助学生同国外多个大学生联系，如哈佛大学、墨尔本大学。**

**②公司为每个国外大学分配一名翻译，如中英翻译、中法翻译。**

要求: 

(1)正确选择设计模式。

(2)画出其类图。

(3)正确解释该类图中的成员角色。

解：对于描述 1)可以选择使用中介者模式，对于描述 2)可以选择使用适配器模式， 
参考类图如下所示： 

![](/d-5.png)

在类图中，各类的角色如下： 

1）旅游公司：抽象中介者； 

2）广之旅：具体中介者； 

3）大学生：抽象同事类； 

4）韶关学院学生：是具体同事类，也是目标抽象类； 

5）哈佛大学生、墨尔本大学生：是具体同事类，也是适配者类； 

6）翻译 1、翻译 2：适配器类。 

### 第七题

**6.假设某远程服务器提供3种功能:功能1(0)、 功能2()、 功能3()。学员如果交100元学费将受到“初级学校”的培训，并获取“初级级别"，这时通过本地代理服务器可以访问远程服务器的“功能10)*;如果再交1000元学费将受到“中级学校”的培训，并获取“中级级别"，这时通过本地代理服务器可以访问远程服务器的“功能1()、功能20)";如果再交1000元学费将受到“高级学校”的培训，并获取“高级级别"，这时通过本地代理服务器可以访问远程服务器的“功能1()、功能2)功能3()”，请根据以上描述完成以下任务。**

(1)正确选择设计模式。

(2)画出其类图。

(3)正确解释该类图中的成员。

解：1）要完成以上功能，需使用“职责链模式”和“代理模式”； 

2）其参考类图如下所示：

![](/d-6.png)

3）在以上类图中，用到了 2 种模式： 

a）职责链模式，其中“学校类”是抽象处理者，“初级学校类、中级学校类、高 级学校类”是具体处理者，“学员类”是请求类； 

b）代理模式，其中“服务器类”是抽象主题类，“代理服务器类”是代理主题类， “远程服务器类”是真实主题类，“学员类”是客户类。

### 第八题

**7![](/d-3.jpg)**

解：1）本题使用了迭代器模式 

2）其参考程序代码如下所示： 

```java
interface Aggregate { Iterator createIterator(); } 
interface Iterator 
{ 
    void first(); 
    void next(); 
    boolean hasNext(); 
    Object currentItem(); 
} 
class ConcreteAggregate implements Aggregate 
{ 
    private Object[] obj={"筷","杯","锅","碗","瓢","盆"}; 
    public Iterator createIterator() { return new ConcreteIterator(); } 
    private class ConcreteIterator implements Iterator 
    { 
        private int currentIndex=0; 
        public void first() { currentIndex=0; } 
        public void next() { if(currentIndex<obj.length){ currentIndex++; }} 
        public boolean hasNext(){ return currentIndex<obj.length; } 
        public Object currentItem(){ return obj[currentIndex]; } 
    } 
} 
class Client 
{ 
    public static void process(Aggregate a) 
    { 
        Iterator i=a.createIterator(); 
        while(i.hasNext()) 
        { 
            System.out.println(i.currentItem().toString()); 
            i.next(); 
        }
    } 
    public static void main(String a[]) 
    { 
        Aggregate a=new ConcreteAggregate(); 
        process(a); 
    } 
} 
```

